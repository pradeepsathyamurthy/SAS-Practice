*******************************;
* Creating samples and Indexes ;
*******************************;

* Basic Introduction about the Chapter;
* Primarily there is a population and a sample;
* Population - It is a whole volume of data;
* Sample - It is a portion from the population under study;
* Index - It is a SAS data structure which indexes one or more column in a dataset;

* Types of Sample;
* Systematic Sample - These are samples taken from a population at a equal interval;
* Random Sample - These are samples taken at a random frequency;

* Random sample can be of two types
	1. Random Sample with replacement - Data are re-occured, once part of sample, it might even re-occur again
	2. Random Sample without replacement - Data is unique, once part of sample, it will not be repeated;

* Index - Index is of two types
	1. Simple Index - Index is based on a one single column
	2. Composite Index - Index is based on more than one column;

* Index can be accessed by both Data step and SQL Step;

* Documenting and Maintaining the Indexes;

* 1. Create a systematic Sample from a known number of observation;
* These are samples chosen at a regular interval from a population;
* Use POINT option in SET statement;
* Remember POINT carries only a varibale and not a constant, value must be given before exc and it is a temp variable;
PROC PRINT DATA=sasuser.revenue;
RUN;
QUIT;
* In below e.g. we are trying to create a new sample data work.revenue_sample from actual dataset sasuser.revenue;
* We are trying to pick data systematically of every 10th observation, starting from observation 1 to 100;
* Thus, it is a systematic sample - This is a direct access read only sample, only reads those which are directed;
* Being Direct read access, there is no EoF marker, thus there is a explicit need of STOP statement to the POINT else loop will be infinite;
* Also, do not forget to add OUTPUT, OUTPUT is the command which will push the data to new dataset;
DATA work.revenue_sample;
	do i = 1 to 100 by 10;
		SET sasuser.revenue POINT=i;
		OUTPUT;
	end;
	STOP;
RUN;
QUIT;
* Below PROC print will produce the result from sampled data;
PROC PRINT DATA = work.revenue_sample;
RUN;
QUIT;

* 2. Create a systematic sample from an unknown number of observation;
* Generally when we read some large dataset, we migh not know the total number of observation;
* In this case we can make use of SAS NOBS function to get the total count and use that with POINT;
* let us assume, we do not know the total count of dataset sasuser.revenue and we need to create a sample of every 10th obs;
* remember the assignment is always NOBS = Var and not var=NOBS, value is automatically assigned during the compilaton;
DATA work.revenue_sample2;
	DO i = 1 to rowcount by 10;
		SET SASUSER.revenue NOBS=rowcount POINT=i;
		OUTPUT;
	END;
	STOP;
RUN;
QUIT;
* Always have a habit of checking the logs after every DATA step submission;
* Below PROC print will produce the result from sampled data;
title "";
footnote "";
PROC PRINT DATA = work.revenue_sample2;
RUN;
QUIT;

* 3. Create a Random Sample with replacement;
* Random Samples are with no systematic data choice and with replacement means observation apprear in sample multiple times;
* This is acheived using one of the SAS random generator function called RANUNI(seed), where seed is some integer value;
* RANUNI(seed) generate values between 0 to 1 exclusive;
* However, to create a sample, value of POINT must match the obs number which is a whole number;
* So we need to CEIL the value returned by RANUNI(seed) and assign that value to POINT;
* CEIL(RANUNI(seed) * 50) if you wish to genrate random number between 0 and 50;
* Let us create a random sample for dataset SASUSER.REVENUE;
* We should decide the sample size before in hand;
DATA WORK.REVENUE_RANDOM_SAMPLE1;
	samplesize=10;
	do i=1 to samplesize;
		rannum = ceil(RANUNI(2)*50);
		SET SASUSER.REVENUE POINT=rannum;
		OUTPUT;
	END;
	STOP;
RUN;
QUIT;
* Let us test the new dataset created;
PROC PRINT DATA = work.REVENUE_RANDOM_SAMPLE1;
RUN;
QUIT;
* let us change the seed to 0;
DATA WORK.REVENUE_RANDOM_SAMPLE1;
	samplesize=10;
	do i=1 to samplesize;
		rannum = ceil(RANUNI(0)*50);
		SET SASUSER.REVENUE POINT=rannum;
		OUTPUT;
	END;
	STOP;
RUN;
QUIT;
* Let us test the new dataset created;
PROC PRINT DATA = work.REVENUE_RANDOM_SAMPLE1;
RUN;
QUIT;
*let us try checking if we are able to generate the same sample with seed=2 as before;
DATA WORK.REVENUE_RANDOM_SAMPLE1;
	samplesize=10;
	do i=1 to samplesize;
		rannum = ceil(RANUNI(2)*50);
		SET SASUSER.REVENUE POINT=rannum;
		OUTPUT;
	END;
	STOP;
RUN;
QUIT;
* Let us test the new dataset created;
* From below PROC PRINT we see when seed=0, values are non replicable, because here, clock initializes the seed everytime;
* However, when the same positive seed is used, for each itiration same observations are selected;
PROC PRINT DATA = work.REVENUE_RANDOM_SAMPLE1;
RUN;
QUIT;

* 4. Create a Random Sample without replacement;
* little complex, lets come to this later;
* These are randome samples, however the observations are not repeated again and thus has no duplicate value;
* This can be only acheived programatically, there is no readymade inbuit SAS functions to do the same, atleast for the timebeing i have studied;

* let us build a random sample without replacement;
DATA WORK.REVENUE_RAND_WITHOUTREP;
	samplesize=10; * defines the sample size, in this e.g. we need 10 observations randomly without replacement;
	obsleft=totobs; * These are count of number of observation left;
	do while(samplesize>0); * Do the iteration while samplesize becomes 0;
		pickit+1;
		rannum = ceil(RANUNI(2)*50); * generating the random number between 0 and 50;
		if rannum<samplesize/obsleft then do; * ;
			SET SASUSER.REVENUE POINT=pickit nobs=totobs;
			OUTPUT;
			samplesize=samplesize-1; * did not underdtand this;
		end;
		obsleft=obsleft-1; * did not underdtand this;
	END;
	STOP;
RUN;
QUIT;

* Let us test the new dataset created;
PROC PRINT DATA = work.REVENUE_RANDOM_WITHOUT_REPLACEMENT;
RUN;
QUIT;

* 5. Use Indexes;
* Index is used to locate an observation quickly using a key variable;
* Thus, yeald a faster, sorted result for BY processing, Perform lookup operation, join and modify an observation;
* Without an index, an observation is searched sequentially from first untill it reaches the desired observation;
* However, index store observations in a sorted order (default ascending) based on the key variable defined;
* Thus, storing the location information as a key-value pair for easy access;
* THere are 2 types of index;
* 	1. Simple Index - Uses one key variable to create an index, by default the name of the index is the name of the key variable;
*	2. Composite Index - Uses two or more (multiple) key variable to create an index, remember the index name should be unique, not the name of a variable used nor any other index name;

* 6. Create Indexes Using DATA step;
* INDEX data set option is used to create index at the time of Data step;
* UNIQUE is used along with INDEX option to create an unique Index;
* Index name apprears as it is defined;
* You can create multiple index on a single dataset - but this will consume system space;
* Create index only for variable which are commenly used in where conditions or on variables used to combine a dataset (PK);
* UNIQUE option makes a dataset's observation unique, for existing dataset if duplicate exist, index cannot be created;
* if unique index is created and then if we try to insert a duplicate observatio, system will not allow to do so;
* 6.1 Simple Index;
PROC PRINT DATA=SASUSER.EMPDATA;
RUN;
QUIT;
* let us create a simple index;
DATA SIMPLE_INDEX1(INDEX=(Division));
	SET sasuser.empdata;
RUN;
QUIT;
* Creating a simple unique index;
* below code will through error because collumn Division has duplicate rows;
DATA SIMPLE_INDEX2(INDEX=(Division/unique));
	SET sasuser.empdata;
RUN;
QUIT;
* Since division is having duplicate values we cannot create unique index on it. However, we can create a simple unique index on variable which are unique;
* In below e.g. two simple index are created, one Simple index based on Division Key Variable;
* Second Index is a simple unique index on EmpID column;
DATA SIMPLE_INDEX3(INDEX=(Division Empid/unique));
	SET sasuser.empdata;
RUN;
QUIT;
* 6.2 Composite Index;
* Note that there is no comma used in the syntax;
* Below we create a composite index named EmpDiv, which is a composition of EmpID and Division;
DATA COMPOSITE_INDEX1(INDEX=(EmpDiv = (Empid Division)));
	SET sasuser.empdata;
RUN;
QUIT;
* 6.3 Verifying index creation and usage;
* MSGLEVEL = I is used to display if the index in created successfully or not;
* it is a part of options command;
* MSGLEVEL=N is defult which displays only Notes, Warning and Error if any;
* MSGLEVEL=I displayes all Informations if index is created, used in a context or not;
OPTIONS MSGLEVEL=i;
RUN;
* Let us test the MSGLEVEL options;
OPTIONS MSGLEVEL=i;
PROC PRINT DATA=sasuser.EMPDATA;
	where Division ne 'FLIGHT OPERATIONS';
RUN;
QUIT;

OPTIONS MSGLEVEL=i;
PROC PRINT DATA=sasuser.EMPDATA;
	where EMPID < 'E50000';
RUN;
QUIT;
* Here you see no index is used in both of these because, all index created above are in WORK folder and not SASUSER folder where actual dataset exist;
* So, be carefull whenever an Index is created;
OPTIONS MSGLEVEL=i;
RUN;
* Let us test the MSGLEVEL options with actual dataset on which an index exist;
OPTIONS MSGLEVEL=i;
PROC PRINT DATA=SIMPLE_INDEX1;
	where Division ne 'FLIGHT OPERATIONS';
RUN;
QUIT;

OPTIONS MSGLEVEL=I;
PROC PRINT DATA=SIMPLE_INDEX1;
	where EMPID < 'E50000';
RUN;
QUIT;

* 7. Manage indexes with PROC DATASETS;
* In above codes we created index only on a new dataset, that is new dataset and index was created in parallel;
* Here, we will see how to create, delete or modify index on a existing dataset;
* Use PROC DATASET with INDEX CREATE, INDEX DELETE and mention MODIFY dataset options;
* Below will list all the datasets in WORK library;
PROC DATASETS library=WORK;
RUN;
QUIT;
* Let us not list the dataset and modify a dataset;
* Below prog create a simple index called empid based on EmpID key variable for the SIMPLE_INDEX1 dataset;
PROC DATASETS library=WORK NOLIST;
modify SIMPLE_INDEX1; * mention the dataset that needs to be modified;
index create empid;
RUN;
QUIT;

* 8. Manage indexes with PROC SQL;
* You can also create and delete index from existing dataset using PROC SQL;
* Use CREATE INDEX and DROP INDEX command inside PORC SQL;
* remember you dont need RUN command for PROC SQL;
PROC SQL;
CREATE INDEX Salary on WORK.SIMPLE_INDEX1(salary);
quit;

* 9. Document and Maintain Indexes;
* If you wish to see all the index created, do not use PROC DATASETS, it will only display Data and Index folder;
* If you need to use PROC DATASETS use it along with CONTENTS option;
* Use PROC CONTENTS to diplay a particular Dataset's detail and associated index for that particular Dataset;
PROC CONTENTS DATA=WORK.SIMPLE_INDEX1;
RUN;
QUIT;
* Index are stored in SAS Data library;
* There is always only one index file for all index for a particular dataset, each index file can contain multiple indexes;
* They do not appear in explorer window or as a seperate file in OS;
* Using PROC DATASET with CONTENTS option;
* This will produce same results like the one above;
* If LIBRARY is mentioned,no need of explicit lib mention in CONTENTS option. However, it is a good practice to maintain lib;
PROC DATASETS library=work;
	CONTENTS DATA=WORK.SIMPLE_INDEX1;
RUN;
QUIT;
* To list the entire dataset and index associated in a library, use _ALL_ option;
PROC CONTENTS DATA=work._ALL_;
RUN;
QUIT;

PROC DATASETS LIBRARY=WORK;
	CONTENTS DATA=WORK._ALL;
RUN;
QUIT;

* 10. Copying the Dataset;
* Use the COPY option in the PROC DATASETS for the same;
* When a dataset is copied, all associated index are also copied with it;
PROC DATASETS LIBRARY=WORK nolist;
	COPY OUT=SASUSER; * remember to use OUT command;
	SELECT SIMPLE_INDEX1;
RUN;
QUIT;
* We can also use PROC COPY;
PROC COPY OUT=SASUSER IN=WORK;
	SELECT SIMPLE_INDEX2;
RUN;
QUIT;
* If you feel you need to Move (that is cut + paste) you need to use MOVE option in PROC COPY;
PROC COPY OUT=SASUSER IN=WORK MOVE;
	SELECT SIMPLE_INDEX2;
RUN;
QUIT;
* If you like to rename a dataset;
* Use CHANGE command;
PROC DATASETS LIBRARY=WORK NOLIST;
	CHANGE SIMPLE_INDEX1 = SIMPLE_INDEX1_MOD;
RUN;
QUIT;
* If you like to rename a variabel in a dataset;
* Use MODIFY command along with RENAME command;
PROC DATASETS LIBRARY=WORK NOLIST;
	MODIFY SIMPLE_INDEX3;
	RENAME EMPID=EMP_ID;
RUN;
QUIT;



