/* Ch-16 - Lookup Tables using Multidimentional array, PROC Transpose and Hashing */

* Multidimentional Array;
PROC PRINT DATA=sasuser.flights(obs=5);
RUN;
QUIT;
* Task is to determine wind chill;
* Creating a 2 dimentional array, whose element are created as temporary elements;
DATA work.wndchill (drop=column row);
	array wc{4,2} _temporary_ (-22,-16,-28,-22,-32,-26,-35,-29);
	set sasuser.flights;
	row=round(wspeed,5)/5; * Significantly we are choosing the respective row number for the array reference;
	put row;
	column=(round(temp,5)/5)+3; * we are choosing the respective column number for the array reference;
	put column;
	windchill=wc{row,column}; * choosing the respective {row,col} from wc array and assignin it to windmill variable;
RUN;
QUIT;
* Printing the value;
PROC PRINT DATA=work.wndchill;
RUN;
QUIT;

* Using stored array value;
* Storing the array values in SAS dataset;
PROC PRINT DATA=sasuser.monthsum (obs=5);
PROC PRINT DATA=sasuser.ctargets (obs=5);
RUN;
QUIT;
* Create a new dataset work.lookup1 which hold the same structure of monthsum by incorporating the values from ctargets;
* From above dataset we see month and year are two common variables;
* Step-1: Create an array - this will hold the values of target dataset - ctarget;
* In arrays we can just mention the range of values for array index, instead of creating a structure and then naming it;
* There are 3 years info for 12 months, so our multidimentiona array should be 3 * 12;
DATA work.lookup1;
	array Targets{1997:1999,12} _temporary_;
	* Step-2: Loading the array element;
	* array needs to be populated with values from ctargets;
	* one way is to use DO loop;
	if _n_=1 then do i=1 to 3; * This just makes the below statements to execute ust once as _n_=1 only for the first record;
		set sasuser.ctargets; * setting data from sasuser.target;
		array Mnth{*} Jan--Dec; * Mnth array to stored the ctargets values; * will enable SAS to automatically count the array elements;
		* astric cannot be used along with _temporary_ array elements, if astrick is given then array elements values need to be defined;
		* -- is used to read the specified values based on their position in the PDV instead alphabatically;
		* DIM is used to find the array dimentions;
		* Step-3: reading target data for 3 years;
		do j=1 to dim(mnth);
			targets{year,j}=mnth{j};
		end;
	end;
	* Step-4: read the actual values from Monthsum and combine;
	* Month and Year needs to be known seperatement from Monthsum to match the record with target;
	set sasuser.monthsum(keep=salemon revcargo monthno);
	year=input(substr(salemon,4),4.);
	ctarget=targets{year,monthno}; * creating respective target from the multidimentional array targets;
	format ctarget dollar15.2;
RUN;
* Printhing the lookup1 dataset;
PROC PRINT DATA=work.lookup1 (Obs=5);
	var salemon revcargo ctarget;
RUN;
QUIT;

* Alternative way for multidimentional stored array - PROC TRANSPOSE;
* Transpose the ctargets table using PROC TRANSPOSE and ;
* merge the transposed data set with Monthsum by the value of year and Month;
/* General structure of PROC TRANSPOSE:
PROC TRANSPOSE DATA=<i/p dataset> OUT=<o/p dataset> NAME=<Initial Col Name> PREFIX=<Prefix of consequtive cols>;
	BY <DESCENDING> <variable-1 used to transpose by group> <DESCENDING> <variable-2> <NOTSORTED>;
	VAR <variable1 variable2 variable3 - these are variables to transpose>;
RUN;
*/
* IF no output dataset name mentioned SAS will creates its own;
* If you omit VAR statement, TRANSPOSE proc will transpose all the numeric variables in the input dataset that are not listed in other statements;
* Must list the character variables in VAR if we need to transpose them, as only numeric variables are teansposed by default;
* Let us apply PROC transpose to ctargets dataset;
PROC PRINT DATA=SASUSER.ctargets(obs=5);
RUN;
PROC TRANSPOSE DATA=sasuser.ctargets out=work.ctarget2;
RUN;
PROC PRINT DATA=work.ctarget2(obs=5);
RUN;
* From above program we see the default namings for columns;
* Since the col headings are transposed to observations, the fisrt col after transformation is namesd as _NAME_ by default;
* Rest of the col are named as COL1 COL2 COL3;
* To take control on this and change the same;
PROC PRINT DATA=work.ctarget2(obs=5);
RUN;
PROC TRANSPOSE DATA=sasuser.ctargets out=work.ctarget3 name=Month prefix=Ctarget;
RUN;
PROC PRINT DATA=work.ctarget3(obs=5);
RUN;
* RENAME = can also be used to change the column name;
* remember RENAME should be used after the OUT= is defined as shown below, else SAS will through error;
PROC PRINT DATA=work.ctarget3(obs=5);
RUN;
PROC TRANSPOSE DATA=sasuser.ctargets out=work.ctarget4 (RENAME=(col1=year1997 col2=year1998 col3=year1999)) name=Month;
RUN;
PROC PRINT DATA=work.ctarget4(obs=5);
RUN;
* Merging the transposed Data;
PROC PRINT DATA=sasuser.monthsum(obs=5);
RUN;
PROC PRINT DATA=work.ctarget2(obs=5);
RUN;
* From above print we see taht structure is totally different and hence cannot be merged properly;
* Year is filling the first row, so we need to correct it;
* BY variable will take care of grouping, that is rows will be grouped according to the BY variable;
PROC TRANSPOSE DATA=sasuser.ctargets
				out=work.ctarget5
				name=Month
				prefix=Ctarget;
	by year;
RUN;
PROC PRINT DATA=work.ctarget5 (obs=5);
RUN;
* Now as a last step, we need to sort the ctarget5 to get it ready to merge;
PROC SORT DATA=work.ctarget5;
	by year month;
run;
* Now we got to re-organize sasuser.monthsum dataset;
PROC PRINT DATA=sasuser.monthsum(obs=5);
RUN;
* from above print we see month and year are clubbed together;
* so we need to seperate them using SUBSTR, INPUT and LOWCASE functions;
DATA work.mnthsum2;
	set sasuser.monthsum(keep=salemon revcargo);
	length month $ 8;
	year=input(substr(salemon,4),4.);
	month=substr(salemon,1,1)||lowcase(substr(salemon,2,2)); * this is to make month column value look like month value in ctarget5;
RUN;
* let us sort it;
PROC SORT DATA=mnthsum2;
	by year month;
RUN;
* printing mnthsum2 dataset created above;
PROC PRINT DATA=work.mnthsum2(obs=5);
RUN;
* Finaly let us merge the data;
DATA work.merged;
	merge work.mnthsum2 work.ctarget5;
	by year month;
RUN;
* Printing the dataset merged with necessary formatting;
PROC PRINT DATA=work.merged (obs=5);
	format ctarget1 dollar15.2;
	var month year revcargo ctarget1;
RUN;

* Hash Objects;
* Hash is like a object oriented approach in SAS;
* It is a good choice for lookup using unordered data;
* When a lookup operation depends on one or more key, we can use hash objects;
* It provides an efficient and convenient mechanism for quick data storage and retreival;
* Hash objects can use any combinations of numeric or character values as addresses;
* It can be loaded from hard-coded value or from a SAS dataset;
* Provides an in-memory storage and retrival;

* Key vs Data Component;
* Hash object consist of Key and a data component;
* Key Component:
	1. Can consist of numeric or char values
	2. maps key values to data rows
	3. must be unique
	4. can be composite;
* Data Component:
	1. contain multiple data values per key
	2. contain both numeric and char values;
* Practice program to find the difference between actual contribution and goal amount;
PROC PRINT DATA=SASUSER.CONTRIB (obs=5);
RUN;
* Data Step Component Object;
* Hash object is a Data step component option - belongs to SCL family - SAS Component Language;
* Component objects are data elements that consist of attributes and methods;
* Attributes: variables (properties that specify the information that is associated with an object);
* Method: functions (operations that an object can perform);

* Declaring a component object - DECLARE;
* To use SAS Data Component Language, must first declare and then create (instantiate) the object;
/* SAmple format to declare an object:
	DECLARE <HASH/HITER object> <Object_Name> <(args_tag_1: value-1,.....,args_tag_n: value-n)>;
HASH indicates it is a hash object and HITER indicates it is a hash iterator object;
Object_name is the name of the object variable;
args_tag specifies the information used to create an instance of component object;
value is the value assigned for args_tag, value depends on the args_tag type;
*/
DATA work.difference (drop=goalamount);
	length goalamount 8;
	if _N_=1 then do;
		declare hash goal;
	end;
RUN;
QUIT;
* Printing the dataset;
* remember PROC PRINT will execute only if there is atleast a vaue in dataset;
PROC PRINT DATA=work.difference;
RUN;
* At this stage only the object is declared, i.e. it has a potential to hold a hash object;
* DECLARE is an executable statement;

* Instantiating an object - _NEW_;
* _NEW_ is used to instantiate the hash object;
* However, this is occatioanlly used, we can Declare and in a same line, we will see that later;
* Instantiating standalone using _NEW_;
DATA work.difference (drop=goalamount);
	length goalamount 8;
	if _N_=1 then do;
		declare hash goal;
		goal= _new_ hash();
	end;
RUN;
QUIT;

* Declaring and Instantiating an object at a same time;
* Below program will declare and instantiate the goal object;
DATA work.difference (drop=goalamount);
	length goalamount 8;
	if _N_=1 then do;
		declare hash goal();
	end;
RUN;
QUIT;

* Defining the Keys and Data - DEFINEKEY, DEFINEDATA, DEFINEDONE;
* Hash objects uses lookup keys to store and retrieve data;
* KEY and DATA are data step variables that we use to initialize with a dot notation method call;
/* format is shown below:
object.method(args_tag1 value, args_tag2 value);
object = hash object name
method = one of the 3 methods DEFINEKEY | DEFINEDATA | DEFINEDONE */
* DEFINEKEY - Key is defined by passing the key variable name to this method;
* DEFINEDATA - Data is defined by passing the data variable name to this method;
* DEFINEDONE - When all key and data variables are defined this method is called to specify that necessary definition is done;
* Key and Data can have any number of Data step variable;
* Variable names are given in double quotes;
* To avoid any Notes appear in SAS log when no explicit assignment to Key or data variable happen, CALL MISSING() function will help;
* CALL MISSING() routine will assign a missing value to specified variable;
* Another way instead of using CALL MISSING() is to assign missing values initially for key and data variable;
DATA work.difference (drop=goalamount);
	length goalamount 8;
	if _N_=1 then do;
		declare hash goal();
		goal.DEFINEKEY("QtrNum");
		goal.DEFINEDATA("GoalAmount");
		goal.DEFINEDONE();
		CALL MISSING(qtrnum, goalamount);
	end;
RUN;
QUIT;

* Loading the Key and Data value - ADD();
* Values are added using the ADD() method;
* Be careful with the value you pass to the key and data value;
DATA work.difference (drop=goalamount);
	length goalamount 8;
	if _N_=1 then do;
		declare hash goal();
		goal.DEFINEKEY("QtrNum");
		goal.DEFINEDATA("GoalAmount");
		goal.DEFINEDONE();
		CALL MISSING(qtrnum, goalamount);
		goal.add(key:1, DATA:10 );
		goal.add(key:2, DATA:15 );
		goal.add(key:3, DATA:5 );
		goal.add(key:4, DATA:15 );
	end;
RUN;
QUIT;

* Retrieving Matching Object - FIND();
* FIND() method is used to retrieve matching data from hash object;
* If FIND() method returns a value, it means that key exist in hash object;
* If key is present, FIND() will also set the dat variable to the value of the data item so that it is available for use after the method call;
PROC PRINT DATA=sasuser.contrib(obs=5);
RUN;
* For somereason i am getting error while running this program - need to debug later;
DATA work.difference (drop=goalamount);
	length goalamount 8;
	if _N_=1 then do;
		declare hash goal( );
		goal.definekey("QtrNum");
		goal.definedata("GoalAmount");
		goal.definedone( );
		call missing(qtrnum, goalamount);
		goal.add(key:'qtr1', data:10 );
		goal.add(key:'qtr2', data:15 );
		goal.add(key:'qtr3', data:5 );
		goal.add(key:'qtr4', data:15 );
	end;
	set sasuser.contrib;
	goal.find();
	Diff=amount-goalamount;
RUN;
QUIT;
* Above program executes until DATA step encounters the end of the line;
* Testing it;
PROC PRINT DATA=work.difference;
RUN;

* Creating hash object from a SAS Dataset;
* Need to disply revenue, expenses, profit and airport information from SASUSER.REVENUE and SASUSER.ACITIES;
PROC PRINT DATA=SASUSER.REVENUE (obs=5);
RUN;
PROC PRINT DATA=SASUSER.Acities (obs=5);
RUN;
* Hash objects can be used to retreive matching airport data from sasuser.acities;
DATA work.report;
	if _N_=1 then do;
		if 0 then set sasuser.acities (keep=code city name);
			declare hash airport(dataset:"sasuser.acities"); * creating hash object from SAS dataset;
			airport.definekey("code");
			airport.definedata("city", "name");
			airport.definedone(); 
			call missing(code,city,name);
			* to define all dataset variable as data variable for hash object, use the ALL:"YES" object in DEFINEDATA() method;
	end;	
	set sasuser.revenue;
	airport.find(key:origin); * we are not validating the retirn code here;
	origincity=city;
	originairport=name;
	airport.find(key:dest);
	destcity=city;
	destairport=name;
RUN;
* Above program give error;

* Using Retirn Code with the FIND method;
* method calls create a return code that is numeric value;
* it can be used in conditional logic to ensure that the FIND method found a KEY value in hash object that matches the KEY value from the PDV;
* Return Code:0 imples success and Return Code: non-zero implies failure;
DATA work.report;
	if _N_=1 then do;
		if 0 then set sasuser.acities (keep=code city name);
			declare hash airport(dataset:"sasuser.acities"); * creating hash object from SAS dataset;
			airport.definekey("code");
			airport.definedata("city", "name");
			airport.definedone(); 
			* to define all dataset variable as data variable for hash object, use the ALL:"YES" object in DEFINEDATA() method;
	end;	
	set sasuser.revenue;
	rc = airport.find(key:origin); * fetching the return code value in variable rc;
	if rc=0 then do;
		origincity=city;
		originairport=name;
	end;
	else do;
		origincity='';
		originairport='';
	end;
	rc = airport.find(key:dest);
	if rc=0 then do;
		destcity=city;
		destairport=name;
	end;
	else do;
		destcity='';
		destairport='';
	end;
RUN;
* Printing the above values;
PROC PRINT DATA=work.report;
	var origin dest flightid date origincity originairport destcity destairport;
RUN;
